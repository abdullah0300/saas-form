<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Flow Canvas Form Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f23;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        .toolbar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            position: relative;
        }
        
        .toolbar h1 {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .toolbar-buttons {
            display: flex;
            gap: 15px;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }
        
        .sidebar {
            width: 300px;
            background: rgba(22, 33, 62, 0.95);
            padding: 25px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .sidebar h3 {
            margin-bottom: 20px;
            color: #4facfe;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .node-palette {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .palette-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 15px;
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            font-weight: 600;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
            user-select: none;
            transform-origin: center;
        }
        
        .palette-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        
        .palette-item:hover::before {
            left: 100%;
        }
        
        .palette-item:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .palette-item:active {
            cursor: grabbing;
            transform: scale(0.95);
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }
        
        .canvas-container.drag-over {
            background: radial-gradient(circle at center, rgba(79, 172, 254, 0.1) 0%, transparent 70%);
        }
        
        .canvas-viewport {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        
        .canvas-viewport.panning {
            cursor: grabbing;
        }
        
        .canvas {
            width: 5000px;
            height: 5000px;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }
        
        .canvas-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.05;
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }
        
        .canvas-grid-fine {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.02;
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 10px 10px;
            pointer-events: none;
        }
        
        .flow-node {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            color: #333;
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            max-width: 300px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            cursor: move;
            border: 3px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            transform-origin: center;
            will-change: transform;
        }
        
        .flow-node::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 15px;
            padding: 3px;
            background: linear-gradient(45deg, #4facfe, #00f2fe, #667eea, #764ba2);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .flow-node:hover::before {
            opacity: 0.5;
        }
        
        .flow-node.selected::before {
            opacity: 1;
        }
        
        .flow-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }
        
        .flow-node.selected {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3); }
            50% { box-shadow: 0 0 0 8px rgba(102, 126, 234, 0.1); }
            100% { box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3); }
        }
        
        .flow-node.dragging {
            cursor: grabbing;
            z-index: 1000;
            transition: none;
            animation: none;
        }
        
        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .node-type {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .node-delete {
            background: #ff4757;
            color: white;
            border: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .node-delete:hover {
            background: #ff3742;
            transform: scale(1.1) rotate(90deg);
        }
        
        .node-content {
            margin-bottom: 15px;
        }
        
        .node-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(255, 255, 255, 0.8);
        }
        
        .node-input:focus {
            outline: none;
            border-color: #4facfe;
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .option-input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .option-input:focus {
            outline: none;
            border-color: #4facfe;
        }
        
        .add-option {
            background: #28a745;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .add-option:hover {
            background: #239a3b;
            transform: translateY(-1px);
        }
        
        .connection-points {
            position: absolute;
        }
        
        .connection-point {
            width: 16px;
            height: 16px;
            background: #4facfe;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            border: 3px solid white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .connection-point::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(79, 172, 254, 0.3) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .connection-point:hover::before {
            opacity: 1;
        }
        
        .connection-point:hover {
            transform: scale(1.3);
            background: #667eea;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
        }
        
        .connection-point.output {
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.input {
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.yes {
            right: -8px;
            top: 30%;
            background: #28a745;
        }
        
        .connection-point.no {
            right: -8px;
            top: 70%;
            background: #ff4757;
        }
        
        .connection-point.connecting {
            animation: connectionPulse 1s infinite;
        }
        
        @keyframes connectionPulse {
            0% { transform: scale(1) translateY(-50%); }
            50% { transform: scale(1.5) translateY(-50%); }
            100% { transform: scale(1) translateY(-50%); }
        }
        
        .svg-connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .connection-line {
            stroke: #4facfe;
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            stroke-dasharray: 10, 5;
            animation: dashFlow 30s linear infinite;
            transition: d 0.1s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .connection-line.yes-connection {
            stroke: #28a745;
        }
        
        .connection-line.no-connection {
            stroke: #ff4757;
        }
        
        @keyframes dashFlow {
            to {
                stroke-dashoffset: -150;
            }
        }
        
        .arrow-marker {
            fill: #4facfe;
        }
        
        .arrow-marker.yes {
            fill: #28a745;
        }
        
        .arrow-marker.no {
            fill: #ff4757;
        }
        
        .temp-line {
            stroke: #ffd93d;
            stroke-width: 3;
            stroke-dasharray: 5,5;
            fill: none;
            filter: drop-shadow(0 2px 8px rgba(255, 217, 61, 0.6));
            animation: tempLineDash 0.5s linear infinite;
        }
        
        @keyframes tempLineDash {
            to {
                stroke-dashoffset: -10;
            }
        }
        
        .mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .properties-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 250px;
            background: rgba(22, 33, 62, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: none;
            transform: translateX(20px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .properties-panel.show {
            display: block;
            transform: translateX(0);
            opacity: 1;
        }
        
        .canvas-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .control-btn {
            background: rgba(22, 33, 62, 0.9);
            color: white;
            border: 2px solid rgba(79, 172, 254, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .control-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(79, 172, 254, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        
        .control-btn:hover::before {
            width: 100%;
            height: 100%;
        }
        
        .control-btn:hover {
            transform: scale(1.1);
            border-color: rgba(79, 172, 254, 0.8);
            color: white;
            z-index: 1;
        }
        
        .drag-preview {
            position: fixed;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%) scale(0.9);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            opacity: 0.9;
            animation: dragScale 0.3s ease;
        }
        
        @keyframes dragScale {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(0.9); }
        }
        
        /* Smooth transitions for canvas transforms */
        .smooth-transition {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Loading animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .loading-overlay.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            position: absolute;
            bottom: 20px;
            right: 240px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #999;
            backdrop-filter: blur(10px);
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .shortcuts-hint:hover {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .sidebar {
                width: 250px;
            }
            
            .toolbar h1 {
                font-size: 1.2rem;
            }
            
            .flow-node {
                min-width: 150px;
                padding: 15px;
            }
            
            .shortcuts-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <h1>üéØ Professional Flow Canvas</h1>
        <div class="toolbar-buttons">
            <button class="btn" onclick="clearCanvas()">Clear All</button>
            <button class="btn" onclick="exportFlow()">Export</button>
            <button class="btn" onclick="previewForm()">Preview</button>
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <h3>üìã Components</h3>
            <div class="node-palette">
                <div class="palette-item" draggable="true" data-type="start">
                    üöÄ Start Node
                </div>
                <div class="palette-item" draggable="true" data-type="text">
                    üìù Text Input
                </div>
                <div class="palette-item" draggable="true" data-type="checkbox">
                    ‚òëÔ∏è Checkbox
                </div>
                <div class="palette-item" draggable="true" data-type="file">
                    üìÅ File Upload
                </div>
                <div class="palette-item" draggable="true" data-type="yesno">
                    üîÄ Yes/No Decision
                </div>
                <div class="palette-item" draggable="true" data-type="end">
                    üèÅ End Node
                </div>
            </div>
            
            <div style="margin-top: 30px;">
                <h3>üîß Instructions</h3>
                <div style="font-size: 12px; line-height: 1.6; color: #ccc;">
                    ‚Ä¢ Drag components to canvas<br>
                    ‚Ä¢ Click nodes to edit properties<br>
                    ‚Ä¢ Drag from connection points to link<br>
                    ‚Ä¢ Yes/No nodes have separate outputs<br>
                    ‚Ä¢ Green = Yes, Red = No<br>
                    ‚Ä¢ <strong>Hold Space + Drag to pan canvas</strong><br>
                    ‚Ä¢ Use zoom controls to navigate<br>
                    ‚Ä¢ Double-click canvas to add node
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-grid"></div>
            <div class="canvas-grid-fine"></div>
            <div class="canvas-viewport" id="canvasViewport">
                <div class="canvas" id="canvas">
                    <svg class="svg-connections" id="svgConnections">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                    refX="10" refY="3.5" orient="auto" class="arrow-marker">
                                <polygon points="0 0, 10 3.5, 0 7" />
                            </marker>
                            <marker id="arrowhead-yes" markerWidth="10" markerHeight="7" 
                                    refX="10" refY="3.5" orient="auto" class="arrow-marker yes">
                                <polygon points="0 0, 10 3.5, 0 7" />
                            </marker>
                            <marker id="arrowhead-no" markerWidth="10" markerHeight="7" 
                                    refX="10" refY="3.5" orient="auto" class="arrow-marker no">
                                <polygon points="0 0, 10 3.5, 0 7" />
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
            
            <div class="canvas-controls">
                <button class="control-btn" onclick="flowCanvas.zoomIn()" title="Zoom In">+</button>
                <button class="control-btn" onclick="flowCanvas.zoomOut()" title="Zoom Out">-</button>
                <button class="control-btn" onclick="flowCanvas.resetView()" title="Reset View">‚åÇ</button>
                <button class="control-btn" onclick="flowCanvas.fitToView()" title="Fit All">‚äû</button>
            </div>
            
            <div class="shortcuts-hint">
                <strong>Shortcuts:</strong> Space+Drag: Pan | Scroll: Zoom | Del: Delete Node
            </div>
            
            <div class="properties-panel" id="propertiesPanel">
                <h3 style="color: #4facfe; margin-bottom: 15px;">Node Properties</h3>
                <div id="propertiesContent"></div>
            </div>
        </div>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <script>
        class FlowCanvas {
            constructor() {
                this.nodes = new Map();
                this.connections = [];
                this.nodeIdCounter = 0;
                this.selectedNode = null;
                this.isDragging = false;
                this.isConnecting = false;
                this.connectionStart = null;
                this.tempLine = null;
                
                // Canvas panning properties
                this.isPanning = false;
                this.panStartX = 0;
                this.panStartY = 0;
                this.canvasX = -2000;
                this.canvasY = -2000;
                this.zoom = 1;
                this.minZoom = 0.1;
                this.maxZoom = 2;
                
                // Animation frame for smooth updates
                this.animationFrame = null;
                this.dragAnimationFrame = null;
                
                this.initializeEventListeners();
                this.addStartNode();
                this.updateCanvasTransform();
            }
            
            initializeEventListeners() {
                const canvas = document.getElementById('canvas');
                const canvasViewport = document.getElementById('canvasViewport');
                const canvasContainer = document.querySelector('.canvas-container');
                const palette = document.querySelector('.node-palette');
                
                // Smooth canvas panning
                canvasViewport.addEventListener('mousedown', (e) => {
                    if (e.button === 1 || (e.button === 0 && e.ctrlKey) || (e.button === 0 && this.spacePressed)) {
                        e.preventDefault();
                        this.startPanning(e);
                    }
                });
                
                canvasViewport.addEventListener('mousemove', (e) => {
                    if (this.isPanning) {
                        this.updatePanning(e);
                    }
                });
                
                canvasViewport.addEventListener('mouseup', (e) => {
                    if (this.isPanning) {
                        this.stopPanning();
                    }
                });
                
                canvasViewport.addEventListener('mouseleave', () => {
                    if (this.isPanning) {
                        this.stopPanning();
                    }
                });
                
                // Smooth zoom with mouse wheel
                let zoomTimeout;
                canvasViewport.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    // Clear any existing timeout
                    clearTimeout(zoomTimeout);
                    
                    // Add smooth transition during zoom
                    canvas.classList.add('smooth-transition');
                    
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoomAt(e.clientX, e.clientY, delta);
                    
                    // Remove smooth transition after zoom completes
                    zoomTimeout = setTimeout(() => {
                        canvas.classList.remove('smooth-transition');
                    }, 300);
                });
                
                // Space key for panning mode
                this.spacePressed = false;
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                        e.preventDefault();
                        this.spacePressed = true;
                        canvasViewport.style.cursor = 'grab';
                    }
                    
                    // Delete key to remove selected node
                    if (e.key === 'Delete' && this.selectedNode) {
                        this.deleteNode(this.selectedNode);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        this.spacePressed = false;
                        if (!this.isPanning) {
                            canvasViewport.style.cursor = 'default';
                        }
                    }
                });
                
                // Double-click to add node
                canvasViewport.addEventListener('dblclick', (e) => {
                    if (e.target === canvasViewport || e.target.closest('.canvas-grid')) {
                        const rect = canvasViewport.getBoundingClientRect();
                        const canvasX = (e.clientX - rect.left - this.canvasX) / this.zoom;
                        const canvasY = (e.clientY - rect.top - this.canvasY) / this.zoom;
                        this.showNodeMenu(canvasX, canvasY);
                    }
                });
                
                // Enhanced drag and drop with visual feedback
                let isDraggingFromPalette = false;
                let draggedNodeType = null;
                let dragPreview = null;
                
                palette.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('palette-item')) {
                        e.preventDefault();
                        isDraggingFromPalette = true;
                        draggedNodeType = e.target.dataset.type;
                        
                        // Create drag preview
                        dragPreview = document.createElement('div');
                        dragPreview.className = 'drag-preview';
                        dragPreview.textContent = e.target.textContent;
                        document.body.appendChild(dragPreview);
                        
                        // Visual feedback
                        e.target.style.opacity = '0.5';
                        e.target.style.transform = 'scale(0.95)';
                        
                        document.body.style.cursor = 'grabbing';
                    }
                });
                
                // Global mouse move for drag preview
                document.addEventListener('mousemove', (e) => {
                    if (isDraggingFromPalette && dragPreview) {
                        dragPreview.style.left = e.clientX + 'px';
                        dragPreview.style.top = e.clientY + 'px';
                        
                        // Visual feedback for canvas
                        const rect = canvasContainer.getBoundingClientRect();
                        if (e.clientX >= rect.left && e.clientX <= rect.right && 
                            e.clientY >= rect.top && e.clientY <= rect.bottom) {
                            canvasContainer.classList.add('drag-over');
                        } else {
                            canvasContainer.classList.remove('drag-over');
                        }
                    }
                });
                
                // Global mouse up for drop
                document.addEventListener('mouseup', (e) => {
                    if (isDraggingFromPalette) {
                        const rect = canvasViewport.getBoundingClientRect();
                        
                        if (e.clientX >= rect.left && e.clientX <= rect.right && 
                            e.clientY >= rect.top && e.clientY <= rect.bottom) {
                            const canvasX = (e.clientX - rect.left - this.canvasX) / this.zoom;
                            const canvasY = (e.clientY - rect.top - this.canvasY) / this.zoom;
                            
                            // Snap to grid
                            const snappedX = Math.round(canvasX / 10) * 10;
                            const snappedY = Math.round(canvasY / 10) * 10;
                            
                            this.createNode(draggedNodeType, snappedX - 100, snappedY - 50);
                        }
                        
                        // Cleanup
                        if (dragPreview) {
                            dragPreview.remove();
                            dragPreview = null;
                        }
                        
                        document.querySelectorAll('.palette-item').forEach(item => {
                            item.style.opacity = '1';
                            item.style.transform = '';
                        });
                        
                        canvasContainer.classList.remove('drag-over');
                        document.body.style.cursor = '';
                        isDraggingFromPalette = false;
                        draggedNodeType = null;
                    }
                });
                
                // Canvas click events
                canvas.addEventListener('click', (e) => {
                    if (e.target === canvas || e.target.classList.contains('canvas-grid')) {
                        this.deselectAllNodes();
                        this.hidePropertiesPanel();
                    }
                });
                
                // Connection events with visual feedback
                canvas.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('connection-point')) {
                        e.stopPropagation();
                        this.startConnection(e.target, e);
                    }
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.isConnecting) {
                        this.updateTempLine(e);
                    }
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    if (this.isConnecting) {
                        this.endConnection(e.target);
                    }
                });
            }
            
            // Smooth panning methods
            startPanning(e) {
                this.isPanning = true;
                this.panStartX = e.clientX - this.canvasX;
                this.panStartY = e.clientY - this.canvasY;
                document.getElementById('canvasViewport').classList.add('panning');
                document.getElementById('canvasViewport').style.cursor = 'grabbing';
            }
            
            updatePanning(e) {
                if (!this.isPanning) return;
                
                cancelAnimationFrame(this.animationFrame);
                this.animationFrame = requestAnimationFrame(() => {
                    this.canvasX = e.clientX - this.panStartX;
                    this.canvasY = e.clientY - this.panStartY;
                    this.updateCanvasTransform();
                });
            }
            
            stopPanning() {
                this.isPanning = false;
                const viewport = document.getElementById('canvasViewport');
                viewport.classList.remove('panning');
                viewport.style.cursor = this.spacePressed ? 'grab' : 'default';
            }
            
            updateCanvasTransform() {
                const canvas = document.getElementById('canvas');
                canvas.style.transform = `translate(${this.canvasX}px, ${this.canvasY}px) scale(${this.zoom})`;
            }
            
            zoomAt(clientX, clientY, factor) {
                const viewport = document.getElementById('canvasViewport');
                const rect = viewport.getBoundingClientRect();
                
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const canvasX = (x - this.canvasX) / this.zoom;
                const canvasY = (y - this.canvasY) / this.zoom;
                
                const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom * factor));
                
                if (newZoom !== this.zoom) {
                    this.canvasX = x - canvasX * newZoom;
                    this.canvasY = y - canvasY * newZoom;
                    this.zoom = newZoom;
                    
                    this.updateCanvasTransform();
                }
            }
            
            zoomIn() {
                const viewport = document.getElementById('canvasViewport');
                const rect = viewport.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const canvas = document.getElementById('canvas');
                canvas.classList.add('smooth-transition');
                
                this.zoomAt(rect.left + centerX, rect.top + centerY, 1.2);
                
                setTimeout(() => {
                    canvas.classList.remove('smooth-transition');
                }, 300);
            }
            
            zoomOut() {
                const viewport = document.getElementById('canvasViewport');
                const rect = viewport.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const canvas = document.getElementById('canvas');
                canvas.classList.add('smooth-transition');
                
                this.zoomAt(rect.left + centerX, rect.top + centerY, 0.8);
                
                setTimeout(() => {
                    canvas.classList.remove('smooth-transition');
                }, 300);
            }
            
            resetView() {
                const canvas = document.getElementById('canvas');
                canvas.classList.add('smooth-transition');
                
                this.canvasX = -2000;
                this.canvasY = -2000;
                this.zoom = 1;
                this.updateCanvasTransform();
                
                setTimeout(() => {
                    canvas.classList.remove('smooth-transition');
                }, 300);
            }
            
            fitToView() {
                if (this.nodes.size === 0) return;
                
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + 300);
                    maxY = Math.max(maxY, node.y + 150);
                });
                
                const padding = 100;
                minX -= padding;
                minY -= padding;
                maxX += padding;
                maxY += padding;
                
                const viewport = document.getElementById('canvasViewport');
                const rect = viewport.getBoundingClientRect();
                
                const contentWidth = maxX - minX;
                const contentHeight = maxY - minY;
                
                const scaleX = rect.width / contentWidth;
                const scaleY = rect.height / contentHeight;
                
                const canvas = document.getElementById('canvas');
                canvas.classList.add('smooth-transition');
                
                this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, Math.min(scaleX, scaleY)));
                this.canvasX = (rect.width - contentWidth * this.zoom) / 2 - minX * this.zoom;
                this.canvasY = (rect.height - contentHeight * this.zoom) / 2 - minY * this.zoom;
                
                this.updateCanvasTransform();
                
                setTimeout(() => {
                    canvas.classList.remove('smooth-transition');
                }, 300);
            }
            
            showNodeMenu(x, y) {
                // Quick node creation menu
                const menu = document.createElement('div');
                menu.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    background: rgba(22, 33, 62, 0.95);
                    border-radius: 10px;
                    padding: 10px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    z-index: 1000;
                    backdrop-filter: blur(10px);
                `;
                
                const types = [
                    { type: 'text', label: 'üìù Text' },
                    { type: 'checkbox', label: '‚òëÔ∏è Checkbox' },
                    { type: 'file', label: 'üìÅ File' },
                    { type: 'yesno', label: 'üîÄ Yes/No' },
                    { type: 'end', label: 'üèÅ End' }
                ];
                
                types.forEach(({ type, label }) => {
                    const item = document.createElement('div');
                    item.textContent = label;
                    item.style.cssText = `
                        padding: 8px 15px;
                        cursor: pointer;
                        border-radius: 5px;
                        margin: 2px 0;
                        transition: background 0.2s;
                        color: white;
                    `;
                    item.onmouseover = () => item.style.background = 'rgba(79, 172, 254, 0.2)';
                    item.onmouseout = () => item.style.background = '';
                    item.onclick = () => {
                        this.createNode(type, x - 100, y - 50);
                        menu.remove();
                    };
                    menu.appendChild(item);
                });
                
                document.getElementById('canvas').appendChild(menu);
                
                // Remove menu when clicking elsewhere
                setTimeout(() => {
                    const removeMenu = (e) => {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', removeMenu);
                        }
                    };
                    document.addEventListener('click', removeMenu);
                }, 100);
            }
            
            addStartNode() {
                this.createNode('start', 2100, 2100);
            }
            
            createNode(type, x, y) {
                const nodeId = `node_${this.nodeIdCounter++}`;
                const node = {
                    id: nodeId,
                    type: type,
                    x: x,
                    y: y,
                    data: this.getDefaultNodeData(type)
                };
                
                this.nodes.set(nodeId, node);
                this.renderNode(node);
                
                // Smooth appearance animation
                const nodeElement = document.getElementById(nodeId);
                nodeElement.style.opacity = '0';
                nodeElement.style.transform = 'scale(0.8)';
                
                requestAnimationFrame(() => {
                    nodeElement.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                    nodeElement.style.opacity = '1';
                    nodeElement.style.transform = 'scale(1)';
                });
                
                return nodeId;
            }
            
            getDefaultNodeData(type) {
                const defaults = {
                    start: { title: 'Start', description: 'Form begins here' },
                    text: { question: 'Enter your question here', placeholder: 'Type your answer...' },
                    checkbox: { question: 'Select options', options: ['Option 1', 'Option 2'] },
                    file: { question: 'Upload a file', acceptedTypes: '*' },
                    yesno: { question: 'Yes or No question?' },
                    end: { title: 'End', message: 'Thank you for completing the form!' }
                };
                return defaults[type] || {};
            }
            
            renderNode(node) {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'flow-node';
                nodeElement.id = node.id;
                nodeElement.style.left = node.x + 'px';
                nodeElement.style.top = node.y + 'px';
                
                nodeElement.innerHTML = this.getNodeHTML(node);
                
                // Add event listeners
                nodeElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectNode(node.id);
                });
                
                nodeElement.addEventListener('mousedown', (e) => {
                    if (!e.target.classList.contains('connection-point') && 
                        !e.target.classList.contains('node-delete') &&
                        !e.target.classList.contains('node-input')) {
                        this.startDragging(node.id, e);
                    }
                });
                
                document.getElementById('canvas').appendChild(nodeElement);
                this.addConnectionPoints(nodeElement, node.type);
            }
            
            getNodeHTML(node) {
                const typeLabels = {
                    start: 'üöÄ START',
                    text: 'üìù TEXT',
                    checkbox: '‚òëÔ∏è CHECKBOX',
                    file: 'üìÅ FILE',
                    yesno: 'üîÄ YES/NO',
                    end: 'üèÅ END'
                };
                
                let contentHTML = '';
                
                switch (node.type) {
                    case 'start':
                        contentHTML = `
                            <div class="node-content">
                                <h4>${node.data.title}</h4>
                                <p style="font-size: 12px; color: #666;">${node.data.description}</p>
                            </div>
                        `;
                        break;
                    
                    case 'text':
                        contentHTML = `
                            <div class="node-content">
                                <input type="text" class="node-input" placeholder="Question text..." 
                                       value="${node.data.question}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'question', this.value)">
                                <input type="text" class="node-input" placeholder="Placeholder text..." 
                                       value="${node.data.placeholder}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'placeholder', this.value)">
                            </div>
                        `;
                        break;
                    
                    case 'checkbox':
                        contentHTML = `
                            <div class="node-content">
                                <input type="text" class="node-input" placeholder="Question text..." 
                                       value="${node.data.question}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'question', this.value)">
                                <div class="checkbox-options">
                                    ${node.data.options.map((opt, i) => 
                                        `<input type="text" class="option-input" value="${opt}" 
                                                onchange="flowCanvas.updateNodeOption('${node.id}', ${i}, this.value)">`
                                    ).join('')}
                                    <button class="add-option" onclick="flowCanvas.addOption('${node.id}')">+ Add Option</button>
                                </div>
                            </div>
                        `;
                        break;
                    
                    case 'file':
                        contentHTML = `
                            <div class="node-content">
                                <input type="text" class="node-input" placeholder="Question text..." 
                                       value="${node.data.question}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'question', this.value)">
                                <input type="text" class="node-input" placeholder="Accepted file types..." 
                                       value="${node.data.acceptedTypes}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'acceptedTypes', this.value)">
                            </div>
                        `;
                        break;
                    
                    case 'yesno':
                        contentHTML = `
                            <div class="node-content">
                                <input type="text" class="node-input" placeholder="Yes/No question..." 
                                       value="${node.data.question}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'question', this.value)">
                                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 10px;">
                                    <span style="color: #28a745;">‚úì YES</span>
                                    <span style="color: #ff4757;">‚úó NO</span>
                                </div>
                            </div>
                        `;
                        break;
                    
                    case 'end':
                        contentHTML = `
                            <div class="node-content">
                                <h4>${node.data.title}</h4>
                                <input type="text" class="node-input" placeholder="End message..." 
                                       value="${node.data.message}" 
                                       onchange="flowCanvas.updateNodeData('${node.id}', 'message', this.value)">
                            </div>
                        `;
                        break;
                }
                
                return `
                    <div class="node-header">
                        <span class="node-type">${typeLabels[node.type]}</span>
                        <button class="node-delete" onclick="flowCanvas.deleteNode('${node.id}')">√ó</button>
                    </div>
                    ${contentHTML}
                `;
            }
            
            addConnectionPoints(nodeElement, nodeType) {
                const existingPoints = nodeElement.querySelectorAll('.connection-point');
                existingPoints.forEach(point => point.remove());
                
                if (nodeType !== 'start') {
                    const inputPoint = document.createElement('div');
                    inputPoint.className = 'connection-point input';
                    inputPoint.dataset.nodeId = nodeElement.id;
                    inputPoint.dataset.type = 'input';
                    nodeElement.appendChild(inputPoint);
                }
                
                if (nodeType !== 'end') {
                    if (nodeType === 'yesno') {
                        const yesPoint = document.createElement('div');
                        yesPoint.className = 'connection-point yes';
                        yesPoint.dataset.nodeId = nodeElement.id;
                        yesPoint.dataset.type = 'yes';
                        yesPoint.title = 'Yes output';
                        nodeElement.appendChild(yesPoint);
                        
                        const noPoint = document.createElement('div');
                        noPoint.className = 'connection-point no';
                        noPoint.dataset.nodeId = nodeElement.id;
                        noPoint.dataset.type = 'no';
                        noPoint.title = 'No output';
                        nodeElement.appendChild(noPoint);
                    } else {
                        const outputPoint = document.createElement('div');
                        outputPoint.className = 'connection-point output';
                        outputPoint.dataset.nodeId = nodeElement.id;
                        outputPoint.dataset.type = 'output';
                        nodeElement.appendChild(outputPoint);
                    }
                }
            }
            
            startConnection(connectionPoint, event) {
                event.stopPropagation();
                
                if (connectionPoint.dataset.type === 'input') return;
                
                this.isConnecting = true;
                this.connectionStart = {
                    nodeId: connectionPoint.dataset.nodeId,
                    type: connectionPoint.dataset.type,
                    element: connectionPoint
                };
                
                // Add visual feedback
                connectionPoint.classList.add('connecting');
                
                // Create temporary line
                const svg = document.getElementById('svgConnections');
                this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.tempLine.classList.add('temp-line');
                svg.appendChild(this.tempLine);
                
                document.body.style.cursor = 'crosshair';
            }
            
            updateTempLine(event) {
                if (!this.tempLine || !this.connectionStart) return;
                
                cancelAnimationFrame(this.dragAnimationFrame);
                this.dragAnimationFrame = requestAnimationFrame(() => {
                    const viewport = document.getElementById('canvasViewport');
                    const rect = viewport.getBoundingClientRect();
                    const startPoint = this.getConnectionPointPosition(this.connectionStart.element);
                    const endX = (event.clientX - rect.left - this.canvasX) / this.zoom;
                    const endY = (event.clientY - rect.top - this.canvasY) / this.zoom;
                    
                    const path = this.createPath(startPoint.x, startPoint.y, endX, endY);
                    this.tempLine.setAttribute('d', path);
                });
            }
            
            endConnection(target) {
                if (!this.isConnecting) return;
                
                this.isConnecting = false;
                document.body.style.cursor = 'default';
                
                // Remove visual feedback
                if (this.connectionStart) {
                    this.connectionStart.element.classList.remove('connecting');
                }
                
                // Remove temporary line
                if (this.tempLine) {
                    this.tempLine.remove();
                    this.tempLine = null;
                }
                
                // Check if target is valid
                if (target && target.classList.contains('connection-point') && 
                    target.dataset.type === 'input' &&
                    target.dataset.nodeId !== this.connectionStart.nodeId) {
                    
                    this.createConnection({
                        from: this.connectionStart.nodeId,
                        to: target.dataset.nodeId,
                        type: this.connectionStart.type
                    });
                }
                
                this.connectionStart = null;
            }
            
            createConnection(connection) {
                const exists = this.connections.some(conn => 
                    conn.from === connection.from && 
                    conn.to === connection.to && 
                    conn.type === connection.type
                );
                
                if (!exists) {
                    this.connections.push(connection);
                    this.renderConnections();
                }
            }
            
            renderConnections() {
                const svg = document.getElementById('svgConnections');
                
                const existingLines = svg.querySelectorAll('.connection-line');
                existingLines.forEach(line => line.remove());
                
                this.connections.forEach(connection => {
                    const fromNode = document.getElementById(connection.from);
                    const toNode = document.getElementById(connection.to);
                    
                    if (!fromNode || !toNode) return;
                    
                    const fromPoint = this.getNodeConnectionPoint(fromNode, connection.type);
                    const toPoint = this.getNodeConnectionPoint(toNode, 'input');
                    
                    if (!fromPoint || !toPoint) return;
                    
                    const fromPos = this.getConnectionPointPosition(fromPoint);
                    const toPos = this.getConnectionPointPosition(toPoint);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    line.classList.add('connection-line');
                    
                    if (connection.type === 'yes') {
                        line.classList.add('yes-connection');
                        line.setAttribute('marker-end', 'url(#arrowhead-yes)');
                    } else if (connection.type === 'no') {
                        line.classList.add('no-connection');
                        line.setAttribute('marker-end', 'url(#arrowhead-no)');
                    } else {
                        line.setAttribute('marker-end', 'url(#arrowhead)');
                    }
                    
                    const path = this.createPath(fromPos.x, fromPos.y, toPos.x, toPos.y);
                    line.setAttribute('d', path);
                    
                    svg.appendChild(line);
                });
            }
            
            createPath(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const controlOffset = Math.min(distance / 2, 150);
                
                // Create smooth bezier curve
                return `M ${x1} ${y1} C ${x1 + controlOffset} ${y1}, ${x2 - controlOffset} ${y2}, ${x2} ${y2}`;
            }
            
            getConnectionPointPosition(element) {
                const rect = element.getBoundingClientRect();
                const viewport = document.getElementById('canvasViewport');
                const viewportRect = viewport.getBoundingClientRect();
                
                return {
                    x: (rect.left + rect.width / 2 - viewportRect.left - this.canvasX) / this.zoom,
                    y: (rect.top + rect.height / 2 - viewportRect.top - this.canvasY) / this.zoom
                };
            }
            
            getNodeConnectionPoint(node, type) {
                return node.querySelector(`.connection-point.${type}`);
            }
            
            selectNode(nodeId) {
                this.deselectAllNodes();
                const nodeElement = document.getElementById(nodeId);
                nodeElement.classList.add('selected');
                this.selectedNode = nodeId;
                this.showPropertiesPanel(nodeId);
            }
            
            deselectAllNodes() {
                document.querySelectorAll('.flow-node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                this.selectedNode = null;
            }
            
            showPropertiesPanel(nodeId) {
                const panel = document.getElementById('propertiesPanel');
                const node = this.nodes.get(nodeId);
                
                if (!node) return;
                
                const content = document.getElementById('propertiesContent');
                content.innerHTML = this.getPropertiesPanelHTML(node);
                
                // Show with animation
                panel.style.display = 'block';
                requestAnimationFrame(() => {
                    panel.classList.add('show');
                });
            }
            
            hidePropertiesPanel() {
                const panel = document.getElementById('propertiesPanel');
                panel.classList.remove('show');
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 300);
            }
            
            getPropertiesPanelHTML(node) {
                let html = `<div style="margin-bottom: 15px;"><strong>Node ID:</strong> ${node.id}</div>`;
                html += `<div style="margin-bottom: 15px;"><strong>Type:</strong> ${node.type}</div>`;
                html += `<div style="margin-bottom: 15px;"><strong>Position:</strong> ${Math.round(node.x)}, ${Math.round(node.y)}</div>`;
                
                switch (node.type) {
                    case 'text':
                        html += `
                            <div style="margin-bottom: 10px;">
                                <label style="font-size: 12px; color: #ccc;">Question:</label>
                                <div style="color: white; font-size: 14px;">${node.data.question}</div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <label style="font-size: 12px; color: #ccc;">Options:</label>
                                <div style="color: white; font-size: 14px;">${node.data.options.join(', ')}</div>
                            </div>
                        `;
                        break;
                }
                
                return html;
            }
            
            startDragging(nodeId, event) {
                const node = this.nodes.get(nodeId);
                const nodeElement = document.getElementById(nodeId);
                
                nodeElement.classList.add('dragging');
                
                const viewport = document.getElementById('canvasViewport');
                const rect = viewport.getBoundingClientRect();
                const canvasX = (event.clientX - rect.left - this.canvasX) / this.zoom;
                const canvasY = (event.clientY - rect.top - this.canvasY) / this.zoom;
                
                const startX = canvasX - node.x;
                const startY = canvasY - node.y;
                
                let lastTime = performance.now();
                let velocityX = 0;
                let velocityY = 0;
                
                const onMouseMove = (e) => {
                    cancelAnimationFrame(this.dragAnimationFrame);
                    this.dragAnimationFrame = requestAnimationFrame(() => {
                        const currentTime = performance.now();
                        const deltaTime = currentTime - lastTime;
                        lastTime = currentTime;
                        
                        const newCanvasX = (e.clientX - rect.left - this.canvasX) / this.zoom;
                        const newCanvasY = (e.clientY - rect.top - this.canvasY) / this.zoom;
                        
                        const prevX = node.x;
                        const prevY = node.y;
                        
                        // Snap to grid while dragging
                        const snapGrid = 10;
                        node.x = Math.round((newCanvasX - startX) / snapGrid) * snapGrid;
                        node.y = Math.round((newCanvasY - startY) / snapGrid) * snapGrid;
                        
                        // Calculate velocity for smooth motion
                        if (deltaTime > 0) {
                            velocityX = (node.x - prevX) / deltaTime;
                            velocityY = (node.y - prevY) / deltaTime;
                        }
                        
                        nodeElement.style.left = node.x + 'px';
                        nodeElement.style.top = node.y + 'px';
                        
                        // Update connections smoothly
                        this.updateConnectionsForNode(nodeId);
                    });
                };
                
                const onMouseUp = () => {
                    nodeElement.classList.remove('dragging');
                    
                    // Apply momentum
                    const deceleration = 0.95;
                    const applyMomentum = () => {
                        if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
                            node.x += velocityX * 16;
                            node.y += velocityY * 16;
                            
                            // Snap to grid
                            node.x = Math.round(node.x / 10) * 10;
                            node.y = Math.round(node.y / 10) * 10;
                            
                            nodeElement.style.left = node.x + 'px';
                            nodeElement.style.top = node.y + 'px';
                            
                            velocityX *= deceleration;
                            velocityY *= deceleration;
                            
                            this.updateConnectionsForNode(nodeId);
                            requestAnimationFrame(applyMomentum);
                        }
                    };
                    
                    // Only apply momentum for fast drags
                    if (Math.abs(velocityX) > 2 || Math.abs(velocityY) > 2) {
                        requestAnimationFrame(applyMomentum);
                    }
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
            
            updateConnectionsForNode(nodeId) {
                // Update only connections related to this node
                const svg = document.getElementById('svgConnections');
                const relevantConnections = this.connections.filter(conn => 
                    conn.from === nodeId || conn.to === nodeId
                );
                
                relevantConnections.forEach(connection => {
                    const lineId = `line_${connection.from}_${connection.to}_${connection.type}`;
                    let line = svg.querySelector(`#${lineId}`);
                    
                    const fromNode = document.getElementById(connection.from);
                    const toNode = document.getElementById(connection.to);
                    
                    if (!fromNode || !toNode) return;
                    
                    const fromPoint = this.getNodeConnectionPoint(fromNode, connection.type);
                    const toPoint = this.getNodeConnectionPoint(toNode, 'input');
                    
                    if (!fromPoint || !toPoint) return;
                    
                    const fromPos = this.getConnectionPointPosition(fromPoint);
                    const toPos = this.getConnectionPointPosition(toPoint);
                    
                    if (!line) {
                        line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        line.id = lineId;
                        line.classList.add('connection-line');
                        
                        if (connection.type === 'yes') {
                            line.classList.add('yes-connection');
                            line.setAttribute('marker-end', 'url(#arrowhead-yes)');
                        } else if (connection.type === 'no') {
                            line.classList.add('no-connection');
                            line.setAttribute('marker-end', 'url(#arrowhead-no)');
                        } else {
                            line.setAttribute('marker-end', 'url(#arrowhead)');
                        }
                        
                        svg.appendChild(line);
                    }
                    
                    const path = this.createPath(fromPos.x, fromPos.y, toPos.x, toPos.y);
                    line.setAttribute('d', path);
                });
            }
            
            updateNodeData(nodeId, key, value) {
                const node = this.nodes.get(nodeId);
                if (node) {
                    node.data[key] = value;
                    if (this.selectedNode === nodeId) {
                        this.showPropertiesPanel(nodeId);
                    }
                }
            }
            
            updateNodeOption(nodeId, index, value) {
                const node = this.nodes.get(nodeId);
                if (node && node.data.options) {
                    node.data.options[index] = value;
                }
            }
            
            addOption(nodeId) {
                const node = this.nodes.get(nodeId);
                if (node && node.data.options) {
                    node.data.options.push(`Option ${node.data.options.length + 1}`);
                    this.refreshNode(nodeId);
                }
            }
            
            refreshNode(nodeId) {
                const nodeElement = document.getElementById(nodeId);
                const node = this.nodes.get(nodeId);
                
                if (nodeElement && node) {
                    nodeElement.innerHTML = this.getNodeHTML(node);
                    this.addConnectionPoints(nodeElement, node.type);
                    this.renderConnections();
                }
            }
            
            deleteNode(nodeId) {
                // Animate node removal
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    nodeElement.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                    nodeElement.style.opacity = '0';
                    nodeElement.style.transform = 'scale(0.8)';
                    
                    setTimeout(() => {
                        // Remove connections
                        this.connections = this.connections.filter(conn => 
                            conn.from !== nodeId && conn.to !== nodeId
                        );
                        
                        // Remove node
                        nodeElement.remove();
                        this.nodes.delete(nodeId);
                        
                        // Update all connections
                        this.renderConnections();
                        
                        // Hide properties panel
                        if (this.selectedNode === nodeId) {
                            this.hidePropertiesPanel();
                        }
                    }, 300);
                }
            }
            
            clearCanvas() {
                if (confirm('Are you sure you want to clear the entire canvas?')) {
                    // Show loading
                    const loading = document.getElementById('loadingOverlay');
                    loading.classList.add('show');
                    
                    setTimeout(() => {
                        this.nodes.clear();
                        this.connections = [];
                        document.getElementById('canvas').innerHTML = `
                            <svg class="svg-connections" id="svgConnections">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                            refX="10" refY="3.5" orient="auto" class="arrow-marker">
                                        <polygon points="0 0, 10 3.5, 0 7" />
                                    </marker>
                                    <marker id="arrowhead-yes" markerWidth="10" markerHeight="7" 
                                            refX="10" refY="3.5" orient="auto" class="arrow-marker yes">
                                        <polygon points="0 0, 10 3.5, 0 7" />
                                    </marker>
                                    <marker id="arrowhead-no" markerWidth="10" markerHeight="7" 
                                            refX="10" refY="3.5" orient="auto" class="arrow-marker no">
                                        <polygon points="0 0, 10 3.5, 0 7" />
                                    </marker>
                                </defs>
                            </svg>
                        `;
                        this.hidePropertiesPanel();
                        this.addStartNode();
                        
                        loading.classList.remove('show');
                    }, 500);
                }
            }
            
            exportFlow() {
                const flowData = {
                    nodes: Array.from(this.nodes.entries()).map(([id, node]) => ({
                        id,
                        ...node
                    })),
                    connections: this.connections
                };
                
                const dataStr = JSON.stringify(flowData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `flow_canvas_${new Date().toISOString().slice(0,10)}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }
            
            previewForm() {
                this.generateFormPreview();
            }
            
            generateFormPreview() {
                const startNode = Array.from(this.nodes.values()).find(node => node.type === 'start');
                if (!startNode) {
                    alert('No start node found!');
                    return;
                }
                
                let formHTML = this.generateFormHTML(startNode.id, new Set());
                
                const previewWindow = window.open('', '_blank', 'width=800,height=600');
                previewWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Form Preview</title>
                        <style>
                            * { margin: 0; padding: 0; box-sizing: border-box; }
                            body { 
                                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
                                padding: 20px; 
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                min-height: 100vh;
                            }
                            .form-container { 
                                max-width: 600px; 
                                margin: 0 auto; 
                                background: white; 
                                padding: 40px; 
                                border-radius: 20px; 
                                box-shadow: 0 20px 60px rgba(0,0,0,0.2);
                            }
                            h1 {
                                color: #333;
                                margin-bottom: 30px;
                                text-align: center;
                            }
                            .question-block { 
                                margin-bottom: 30px; 
                                padding: 25px; 
                                border-left: 4px solid #4facfe; 
                                background: #f8f9fa;
                                border-radius: 10px;
                                transition: all 0.3s ease;
                            }
                            .question-block:hover {
                                box-shadow: 0 5px 20px rgba(79, 172, 254, 0.1);
                                transform: translateY(-2px);
                            }
                            .question-title { 
                                font-size: 18px; 
                                font-weight: 600; 
                                margin-bottom: 15px; 
                                color: #333; 
                            }
                            .form-input { 
                                width: 100%; 
                                padding: 12px 16px; 
                                border: 2px solid #e1e8ed; 
                                border-radius: 8px; 
                                font-size: 16px;
                                transition: all 0.3s ease;
                            }
                            .form-input:focus {
                                outline: none;
                                border-color: #4facfe;
                                box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
                            }
                            .checkbox-group { 
                                display: flex; 
                                flex-direction: column; 
                                gap: 12px; 
                            }
                            .checkbox-item { 
                                display: flex; 
                                align-items: center; 
                                gap: 10px;
                                padding: 8px;
                                border-radius: 6px;
                                transition: background 0.2s;
                            }
                            .checkbox-item:hover {
                                background: rgba(79, 172, 254, 0.05);
                            }
                            .checkbox-item input[type="checkbox"] {
                                width: 20px;
                                height: 20px;
                                cursor: pointer;
                            }
                            .radio-group { 
                                display: flex; 
                                gap: 30px;
                                padding: 10px 0;
                            }
                            .radio-item { 
                                display: flex; 
                                align-items: center; 
                                gap: 10px;
                                padding: 10px 20px;
                                border: 2px solid #e1e8ed;
                                border-radius: 25px;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            }
                            .radio-item:hover {
                                border-color: #4facfe;
                                background: rgba(79, 172, 254, 0.05);
                            }
                            .radio-item input[type="radio"] {
                                width: 18px;
                                height: 18px;
                                cursor: pointer;
                            }
                            .file-upload { 
                                border: 2px dashed #4facfe; 
                                padding: 30px; 
                                text-align: center; 
                                border-radius: 10px;
                                background: rgba(79, 172, 254, 0.05);
                                transition: all 0.3s ease;
                                cursor: pointer;
                            }
                            .file-upload:hover {
                                border-color: #667eea;
                                background: rgba(79, 172, 254, 0.1);
                            }
                            .conditional-section { 
                                margin-left: 20px; 
                                margin-top: 20px; 
                                padding: 20px; 
                                background: #fff3cd; 
                                border-radius: 10px;
                                border: 2px solid #ffeaa7;
                            }
                            .btn { 
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                color: white; 
                                padding: 14px 30px; 
                                border: none; 
                                border-radius: 25px; 
                                cursor: pointer; 
                                font-size: 16px;
                                font-weight: 600;
                                text-transform: uppercase;
                                letter-spacing: 1px;
                                transition: all 0.3s ease;
                                display: block;
                                margin: 0 auto;
                                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                            }
                            .btn:hover {
                                transform: translateY(-2px);
                                box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
                            }
                        </style>
                    </head>
                    <body>
                        <div class="form-container">
                            <h1>Form Preview</h1>
                            <form id="previewForm">
                                ${formHTML}
                                <button type="button" class="btn" onclick="alert('Form submitted successfully! (This is just a preview)')">Submit Form</button>
                            </form>
                        </div>
                    </body>
                    </html>
                `);
                previewWindow.document.close();
            }
            
            generateFormHTML(nodeId, visited) {
                if (visited.has(nodeId)) return '';
                visited.add(nodeId);
                
                const node = this.nodes.get(nodeId);
                if (!node || node.type === 'start') {
                    const nextConnection = this.connections.find(conn => conn.from === nodeId);
                    if (nextConnection) {
                        return this.generateFormHTML(nextConnection.to, visited);
                    }
                    return '';
                }
                
                if (node.type === 'end') {
                    return `<div class="question-block"><h3>${node.data.title}</h3><p>${node.data.message}</p></div>`;
                }
                
                let html = `<div class="question-block"><div class="question-title">${node.data.question}</div>`;
                
                switch (node.type) {
                    case 'text':
                        html += `<input type="text" class="form-input" placeholder="${node.data.placeholder}">`;
                        break;
                    case 'checkbox':
                        html += '<div class="checkbox-group">';
                        node.data.options.forEach((option, i) => {
                            html += `<div class="checkbox-item"><input type="checkbox" id="cb${nodeId}_${i}"><label for="cb${nodeId}_${i}">${option}</label></div>`;
                        });
                        html += '</div>';
                        break;
                    case 'file':
                        html += `<div class="file-upload"><input type="file" accept="${node.data.acceptedTypes}" style="display: none;" id="file${nodeId}"><label for="file${nodeId}">üìÅ Click to upload file</label></div>`;
                        break;
                    case 'yesno':
                        html += '<div class="radio-group">';
                        html += `<div class="radio-item"><input type="radio" name="yn${nodeId}" id="yes${nodeId}"><label for="yes${nodeId}">‚úì Yes</label></div>`;
                        html += `<div class="radio-item"><input type="radio" name="yn${nodeId}" id="no${nodeId}"><label for="no${nodeId}">‚úó No</label></div>`;
                        html += '</div>';
                        
                        const yesConnection = this.connections.find(conn => conn.from === nodeId && conn.type === 'yes');
                        const noConnection = this.connections.find(conn => conn.from === nodeId && conn.type === 'no');
                        
                        if (yesConnection) {
                            html += `<div class="conditional-section"><strong>If Yes:</strong>${this.generateFormHTML(yesConnection.to, new Set(visited))}</div>`;
                        }
                        if (noConnection) {
                            html += `<div class="conditional-section"><strong>If No:</strong>${this.generateFormHTML(noConnection.to, new Set(visited))}</div>`;
                        }
                        
                        html += '</div>';
                        return html;
                }
                
                html += '</div>';
                
                const nextConnection = this.connections.find(conn => conn.from === nodeId && conn.type === 'output');
                if (nextConnection) {
                    html += this.generateFormHTML(nextConnection.to, visited);
                }
                
                return html;
            }
        }
        
        // Global functions
        let flowCanvas;
        
        window.addEventListener('DOMContentLoaded', () => {
            flowCanvas = new FlowCanvas();
        });
        
        function clearCanvas() {
            flowCanvas.clearCanvas();
        }
        
        function exportFlow() {
            flowCanvas.exportFlow();
        }
        
        function previewForm() {
            flowCanvas.previewForm();
        }
    </script>
</body>
</html>